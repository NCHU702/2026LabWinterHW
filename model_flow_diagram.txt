HydroNetRainOnly 模型資訊流圖 (3-Layer 版本)
=============================================

輸入 Input (來自 Dataset):
  x: (batch, seq_len, 1, H, W)
  
  實際尺寸 (padding 後):
  - batch=2: 批次大小
  - seq_len=9: 時間序列長度
    ├─ 時間步 0~5 (t-5 ~ t): 過去 6 小時的觀測降雨
    └─ 時間步 6~8 (t+1 ~ t+3): 未來 3 小時的預報降雨（含擾動）
  - 1: 單通道（降雨量）
  - H=640, W=776: 原始 636×772 經 pad_multiple=8 補齊


═══════════════════════════════════════════════════════════════════
  ENCODER - 逐時間步處理（t = 0 到 8，共 9 個時間步）
═══════════════════════════════════════════════════════════════════

初始化狀態:
  h1, c1: (batch, 16, H, W)       = (2, 16, 640, 776)
  h2, c2: (batch, 32, H//2, W//2) = (2, 32, 320, 388)
  h3, c3: (batch, 64, H//4, W//4) = (2, 64, 160, 194)

每個時間步 t 的處理流程:
  
  ┌────────────────────────────────────────────────────────┐
  │ 輸入: x[:, t]                                          │
  │ (batch, 1, H, W) = (2, 1, 640, 776)                   │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    ENCODER LAYER 1        ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ Conv2d(1→16, kernel=3, padding=1)                      │
  │ 提取空間特徵                                            │
  │ 輸出: (2, 16, 640, 776)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ LeakyReLU(0.2)                                         │
  │ conv_out1: (2, 16, 640, 776)                           │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ ConvLSTMCell(input_dim=16, hidden_dim=16, kernel=3)    │
  │ 輸入: conv_out1 + (h1, c1)                             │
  │ 輸出: h1, c1 (更新後的狀態)                            │
  │       (2, 16, 640, 776)                                │
  │                                                        │
  │ LSTM 門控機制:                                         │
  │   i_t = σ(W_i * [h_{t-1}, x_t])  # input gate        │
  │   f_t = σ(W_f * [h_{t-1}, x_t])  # forget gate       │
  │   o_t = σ(W_o * [h_{t-1}, x_t])  # output gate       │
  │   g_t = tanh(W_g * [h_{t-1}, x_t]) # cell gate       │
  │   c_t = f_t ⊙ c_{t-1} + i_t ⊙ g_t                    │
  │   h_t = o_t ⊙ tanh(c_t)                               │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ MaxPool2d(kernel=2, stride=2)                          │
  │ 空間下採樣 ↓2                                          │
  │ pooled1: (2, 16, 320, 388)                             │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    ENCODER LAYER 2        ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ Conv2d(16→32, kernel=3, padding=1)                     │
  │ 深層特徵提取                                            │
  │ 輸出: (2, 32, 320, 388)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ LeakyReLU(0.2)                                         │
  │ conv_out2: (2, 32, 320, 388)                           │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ ConvLSTMCell(input_dim=32, hidden_dim=32, kernel=3)    │
  │ 輸入: conv_out2 + (h2, c2)                             │
  │ 輸出: h2, c2 (更新後的狀態)                            │
  │       (2, 32, 320, 388)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ MaxPool2d(kernel=2, stride=2)                          │
  │ 空間下採樣 ↓2                                          │
  │ pooled2: (2, 32, 160, 194)                             │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    ENCODER LAYER 3        ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ Conv2d(32→64, kernel=3, padding=1)                     │
  │ 更深層特徵提取                                          │
  │ 輸出: (2, 64, 160, 194)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ LeakyReLU(0.2)                                         │
  │ conv_out3: (2, 64, 160, 194)                           │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ ConvLSTMCell(input_dim=64, hidden_dim=64, kernel=3)    │
  │ 輸入: conv_out3 + (h3, c3)                             │
  │ 輸出: h3, c3 (更新後的狀態)                            │
  │       (2, 64, 160, 194)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ MaxPool2d(kernel=2, stride=2)                          │
  │ 空間下採樣 ↓2                                          │
  │ pooled3: (2, 64, 80, 97)                               │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ 保存策略:                                              │
  │   if t >= 6:  # 時間步 6, 7, 8 (對應 t+1, t+2, t+3)   │
  │       h3_futures.append(pooled3)                       │
  │                                                        │
  │ 保存內容:                                              │
  │   h3_futures[0] = pooled3_{t+1}  # 時間步 6 的輸出    │
  │   h3_futures[1] = pooled3_{t+2}  # 時間步 7 的輸出    │
  │   h3_futures[2] = pooled3_{t+3}  # 時間步 8 的輸出    │
  └────────────────────────────────────────────────────────┘

                   循環 9 次，處理所有時間步
                   ↓
               完成 Encoder


═══════════════════════════════════════════════════════════════════
  DECODER - 對未來 3 個時間步分別解碼
═══════════════════════════════════════════════════════════════════

對於每個預測時間步 t ∈ {t+1, t+2, t+3}:

  ┌────────────────────────────────────────────────────────┐
  │ 輸入: h3_futures[t-1]                                  │
  │ (2, 64, 80, 97)                                        │
  │                                                        │
  │ 說明:                                                  │
  │   t+1 預測 ← h3_futures[0] (時間步 6 的 Block3 輸出)  │
  │   t+2 預測 ← h3_futures[1] (時間步 7 的 Block3 輸出)  │
  │   t+3 預測 ← h3_futures[2] (時間步 8 的 Block3 輸出)  │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    DECODER LAYER 1        ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ ConvTranspose2d(64→32, kernel=3, stride=2)             │
  │ 上採樣 ↑2                                              │
  │ 輸出: (2, 32, 160, 194)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ LeakyReLU(0.2)                                         │
  │ d1: (2, 32, 160, 194)                                  │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    DECODER LAYER 2        ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ ConvTranspose2d(32→16, kernel=3, stride=2)             │
  │ 上採樣 ↑2                                              │
  │ 輸出: (2, 16, 320, 388)                                │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ LeakyReLU(0.2)                                         │
  │ d2: (2, 16, 320, 388)                                  │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    DECODER LAYER 3        ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ ConvTranspose2d(16→8, kernel=3, stride=2)              │
  │ 上採樣 ↑2 (恢復到原始解析度)                           │
  │ 輸出: (2, 8, 640, 776)                                 │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ LeakyReLU(0.2)                                         │
  │ d3: (2, 8, 640, 776)                                   │
  └────────────────────┬───────────────────────────────────┘
                       │
         ╔═════════════╩═════════════╗
         ║    OUTPUT LAYER           ║
         ╚═════════════╦═════════════╝
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ Conv2d(8→1, kernel=3, padding=1)                       │
  │ 最終卷積，生成淹水增量預測                             │
  │ 輸出: (2, 1, 640, 776)                                 │
  └────────────────────┬───────────────────────────────────┘
                       │
                       ▼
  ┌────────────────────────────────────────────────────────┐
  │ 直接輸出（無激活函數）                                  │
  │ pred_t: (2, 1, 640, 776)                               │
  │                                                        │
  │ 說明: 允許正值（水漲）和負值（水退）                   │
  │   正值: 淹水加深                                       │
  │   負值: 淹水退去                                       │
  │   零值: 水位不變                                       │
  │                                                        │
  │ 儲存到 predictions 列表                                │
  └────────────────────────────────────────────────────────┘

                  重複 3 次（t+1, t+2, t+3）
                           ↓

  ┌────────────────────────────────────────────────────────┐
  │ torch.stack(predictions, dim=1)                        │
  │ 堆疊所有預測結果                                        │
  │ out: (2, 3, 1, 640, 776)                               │
  └────────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════
  尺寸變化總覽
═══════════════════════════════════════════════════════════════════

原始資料: 636 × 772
Padding後: 640 × 776 (需為 8 的倍數，因 2^3=8)

┌─────────────────────────────────────────────────────────────────┐
│                        ENCODER                                  │
├─────────────────────────────────────────────────────────────────┤
│ 階段          │ 通道數  │ 空間尺寸        │ 操作               │
├───────────────┼─────────┼─────────────────┼────────────────────┤
│ 輸入          │ 1       │ 640 × 776       │ -                  │
│ Encoder L1    │ 16      │ 640 × 776       │ Conv+LSTM          │
│ Pool1         │ 16      │ 320 × 388       │ MaxPool ↓2         │
│ Encoder L2    │ 32      │ 320 × 388       │ Conv+LSTM          │
│ Pool2         │ 32      │ 160 × 194       │ MaxPool ↓2         │
│ Encoder L3    │ 64      │ 160 × 194       │ Conv+LSTM          │
│ Pool3         │ 64      │ 80 × 97         │ MaxPool ↓2         │
└───────────────┴─────────┴─────────────────┴────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        DECODER                                  │
├─────────────────────────────────────────────────────────────────┤
│ 階段          │ 通道數  │ 空間尺寸        │ 操作               │
├───────────────┼─────────┼─────────────────┼────────────────────┤
│ 輸入          │ 64      │ 80 × 97         │ h3_futures         │
│ Decoder L1    │ 32      │ 160 × 194       │ ConvTranspose ↑2   │
│ Decoder L2    │ 16      │ 320 × 388       │ ConvTranspose ↑2   │
│ Decoder L3    │ 8       │ 640 × 776       │ ConvTranspose ↑2   │
│ Output        │ 1       │ 640 × 776       │ Conv               │
└───────────────┴─────────┴─────────────────┴────────────────────┘

空間縮減率: 640/80 = 8 (下採樣 3 次, 2^3 = 8)


═══════════════════════════════════════════════════════════════════
  輸出 Output
═══════════════════════════════════════════════════════════════════

out: (batch, 3, 1, H, W) = (2, 3, 1, 640, 776)

說明:
- batch=2: 批次大小
- 3: 未來 3 個時間步
  ├─ out[:, 0] → t+1 小時的淹水增量預測
  ├─ out[:, 1] → t+2 小時的淹水增量預測
  └─ out[:, 2] → t+3 小時的淹水增量預測
- 1: 單通道（淹水增量深度）
- H×W: 與輸入相同的空間維度 (640×776)


═══════════════════════════════════════════════════════════════════
  與 Dataset 的對應關係
═══════════════════════════════════════════════════════════════════

Dataset 輸出 (StochasticRainDataset.__getitem__):
  - input_pad:  [9, 1, 640, 776]  → DataLoader → [batch, 9, 1, 640, 776]
  - target_pad: [3, 1, 640, 776]  → DataLoader → [batch, 3, 1, 640, 776]
  - mask_pad:   [3, 1, 640, 776]  → DataLoader → [batch, 3, 1, 640, 776]

模型輸入/輸出:
  - 輸入: (batch, 9, 1, 640, 776)  ← 9 個時間步的降雨序列
  - 輸出: (batch, 3, 1, 640, 776)  ← 3 個時間步的淹水增量預測
  - 目標: (batch, 3, 1, 640, 776)  ← 實際淹水增量（ground truth）

完美匹配！✓


═══════════════════════════════════════════════════════════════════
  關鍵設計概念與架構邏輯
═══════════════════════════════════════════════════════════════════

1. 三層 Encoder 架構：
   ┌─────────────────────────────────────────────────────┐
   │ Layer 1: 處理原始降雨 → 低層次時空特徵 (16 ch)      │
   │ Layer 2: 處理 Layer 1 輸出 → 中層次時空特徵 (32 ch) │
   │ Layer 3: 處理 Layer 2 輸出 → 高層次時空特徵 (64 ch) │
   └─────────────────────────────────────────────────────┘
   
   • 每層都有獨立的 ConvLSTM，累積時序信息
   • 每層輸入是上一層當前時間步的輸出
   • 形成三階層式特徵提取

2. 時序處理機制：
   ┌─────────────────────────────────────────────────────────────┐
   │ t=0: [t-5] → L1 → Pool → L2 → Pool → L3 → Pool             │
   │ t=1: [t-4] → L1 → Pool → L2 → Pool → L3 → Pool             │
   │ t=2: [t-3] → L1 → Pool → L2 → Pool → L3 → Pool             │
   │ ...                                                         │
   │ t=6: [t+1] → L1 → Pool → L2 → Pool → L3 → Pool ← 保存      │
   │ t=7: [t+2] → L1 → Pool → L2 → Pool → L3 → Pool ← 保存      │
   │ t=8: [t+3] → L1 → Pool → L2 → Pool → L3 → Pool ← 保存      │
   └─────────────────────────────────────────────────────────────┘
   
   • 所有時間步共享 CNN 和 LSTM 權重
   • LSTM 狀態持續更新，捕捉時序依賴
   • 保存對應未來時間的 Block3 輸出用於預測

3. 多時間步預測策略：
   ┌─────────────────────────────────────────────────────┐
   │ t+1 預測 ← 使用時間步 6 的 Block3 輸出             │
   │ t+2 預測 ← 使用時間步 7 的 Block3 輸出             │
   │ t+3 預測 ← 使用時間步 8 的 Block3 輸出             │
   └─────────────────────────────────────────────────────┘
   
   • 每個預測對應其時間步的降雨輸入
   • Decoder 權重共享，處理不同時間步的特徵
   • 符合物理意義：t+k 的降雨影響 t+k 的淹水

4. 空間維度變化：
   ┌─────────────────────────────────────────────────────┐
   │ 輸入:      640 × 776                                │
   │ Pool1:     320 × 388   (↓2)                         │
   │ Pool2:     160 × 194   (↓4)                         │
   │ Pool3:     80 × 97     (↓8)                         │
   │ Upsample1: 160 × 194   (↑2)                         │
   │ Upsample2: 320 × 388   (↑4)                         │
   │ Upsample3: 640 × 776   (↑8)                         │
   └─────────────────────────────────────────────────────┘
   
   • 3 次下採樣 + 3 次上採樣
   • 保證輸入輸出空間維度一致
   • 需要 pad_multiple=8 確保整除

5. 通道數變化：
   ┌─────────────────────────────────────────────────────┐
   │ Encoder:  1 → 16 → 32 → 64                          │
   │ Decoder:  64 → 32 → 16 → 8 → 1                      │
   └─────────────────────────────────────────────────────┘
   
   • 逐層增加特徵複雜度
   • 最終收斂到單通道輸出

6. 激活函數選擇：
   ┌─────────────────────────────────────────────────────┐
   │ 中間層: LeakyReLU(0.2) - 避免死神經元               │
   │ 輸出層: 無激活函數 - 允許淹水增量為正或負           │
   │ LSTM 內部: Sigmoid + Tanh - 標準 LSTM 門控          │
   └─────────────────────────────────────────────────────┘

7. 預測目標：
   ┌─────────────────────────────────────────────────────┐
   │ 預測的是淹水「增量」，而非累積值                     │
   │ target[t] = flood_depth[t] - flood_depth[t-1]       │
   │ 可以是正值（水漲）、負值（水退）或零（不變）         │
   │ 更容易學習，避免累積誤差                             │
   └─────────────────────────────────────────────────────┘


═══════════════════════════════════════════════════════════════════
  模型參數統計
═══════════════════════════════════════════════════════════════════

Encoder Layer 1:
  - Conv1:      1×16×3×3 + 16 = 160 參數
  - LSTM1:      (16+16)×(4×16)×3×3 = 18,432 參數
  
Encoder Layer 2:
  - Conv2:      16×32×3×3 + 32 = 4,640 參數
  - LSTM2:      (32+32)×(4×32)×3×3 = 73,728 參數

Encoder Layer 3:
  - Conv3:      32×64×3×3 + 64 = 18,496 參數
  - LSTM3:      (64+64)×(4×64)×3×3 = 294,912 參數

Decoder:
  - DecConv1:   64×32×3×3 + 32 = 18,464 參數
  - DecConv2:   32×16×3×3 + 16 = 4,624 參數
  - DecConv3:   16×8×3×3 + 8 = 1,160 參數
  - Final:      8×1×3×3 + 1 = 73 參數

總參數量: 約 435,137 參數 (~4倍於 2-Layer 版本)


═══════════════════════════════════════════════════════════════════
  架構優勢
═══════════════════════════════════════════════════════════════════

✓ 更深特徵學習：三層 Encoder 提取更抽象的時空特徵
✓ 更大感受野：更多層 Pool/Upsample 擴大空間感受野
✓ 更強表達能力：參數量增加 4 倍，模型容量更大
✓ 時空特徵學習：ConvLSTM 同時處理空間和時序信息
✓ 階層式編碼：三層 Encoder 提取不同層次的特徵
✓ 權重共享：參數效率高，減少過擬合風險
✓ 物理一致性：預測與對應時間步的降雨直接關聯
✓ 端到端訓練：無需複雜的後處理步驟
✓ 彈性擴展：易於增加更多層或修改通道數


═══════════════════════════════════════════════════════════════════
  配置參數 (config.py)
═══════════════════════════════════════════════════════════════════

• batch_size: 2
• learning_rate: 1e-4
• weight_decay: 1e-5
• num_epochs: 64
• early_stopping_patience: 10
• flood_weight: 50.0  (淹水區域權重)
• target_scale: 10.0  (目標值縮放)
• pad_multiple: 8     (需為 2^3=8 的倍數)
